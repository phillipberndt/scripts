#!/usr/bin/env python
#
# Replacement for the Perl gdo
# Quick & dirty implementation
#
# TODO Multiple patterns are currently OR'ed. AND them, as before. Support
#      backreferencing to any pattern.
#
from __future__ import print_function
import sys

import argparse
import os
import re
import pipes
import subprocess

REMAINDER_HELP = """As parameters, supply a PCRE mattern (or multiple patterns,
    which are logically OR chained, where you'll need to prefix every pattern
    starting from the 2nd with a +), and optionally a command line to be invoked
    using the results. You can use backreferencing ($1..) in the command line. If
    you skip the command, it defaults to echo."""

def main():
    parser = argparse.ArgumentParser(description="find -regex FOO -exec BAR replacement with PCRE support")
    parser.add_argument("-t", dest="test", help="Test. Don't execute the substituted command but output it only.", action="store_true")
    parser.add_argument("-d", dest="directory", help="The directory to search in. Defaults to ./", default="./")
    parser.add_argument("args", nargs=argparse.REMAINDER, help=REMAINDER_HELP)
    args = parser.parse_args()

    patterns = []
    command_line = []

    in_pattern = True
    has_dollar_replacement = False

    for arg in args.args:
        if in_pattern and (not patterns or arg[0] == "+"):
            if arg and arg[0] == "+":
                arg = arg[1:]
            patterns.append(re.compile(arg, re.IGNORECASE))
        else:
            in_pattern = False
            if arg and arg[0] in ("$", "%"):
                has_dollar_replacement = True
            command_line.append(arg)

    if not patterns:
        patterns.append(re.compile("."))

    if command_line and not has_dollar_replacement:
        command_line.append("$0")

    def gen_command_line_builder(command):
        if command[0] in ("$", "%") and command[1:].isdigit():
            group = int(command[1:])
            if group == 0:
                return lambda match: match.string
            return lambda match: match.group(group)
        else:
            return lambda match: command

    execable_command_line = []
    for command in command_line:
        execable_command_line.append(gen_command_line_builder(command))

    command_line_builder = lambda match: [ x(match) for x in execable_command_line ]

    output_to_tty = sys.stdout.isatty()

    for root, dirs, files in os.walk(args.directory):
        for file_name in files:
            full_path = os.path.join(root, file_name)
            for pattern in patterns:
                result = pattern.search(full_path)
                if result:
                    if not command_line:
                        if output_to_tty:
                            left, right = result.span()
                            print(full_path[:left], "\033[31m", full_path[left:right], "\033[39m", full_path[right:], sep="")
                        else:
                            print(full_path)
                    else:
                        this_match_command = map(pipes.quote, command_line_builder(result))
                        joined_command = " ".join(this_match_command)
                        if args.test:
                            print(joined_command)
                        else:
                            subprocess.call(joined_command, shell=True)
                    break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
